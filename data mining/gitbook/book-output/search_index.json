[["naivebayes.html", "Module 3 Probabilistic Learning with Naive Bayes Classification 3.1 Business Case: Filtering Spam 3.2 Data Understanding 3.3 Preparation 3.4 Modeling 3.5 Evaluation", " Module 3 Probabilistic Learning with Naive Bayes Classification 3.1 Business Case: Filtering Spam In 2020 spam account for more than 50% of total e-mail traffic (“Spam Statistics: Spam E-Mail Traffic Share 2019” n.d.). This illustrates the value of a good spam filter. Naive Bayes spam filtering is a standard technique for handling spam. It is one of the oldest ways of doing spam filtering, with roots in the 1990s. 3.2 Data Understanding The data we’ll use comes from the SMS Spam Collection (“UCI Machine Learning Repository: SMS Spam Collection Data Set” n.d.). It contains a set SMS messages that are label ‘ham’ or ‘spam’. and is a standard data set for testing spam filtering methods. url &lt;- &quot;datasets/smsspam.csv&quot; rawDF &lt;- read_csv(url) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## type = col_character(), ## text = col_character() ## ) head(rawDF) ## # A tibble: 6 x 2 ## type text ## &lt;chr&gt; &lt;chr&gt; ## 1 ham Go until jurong point, crazy.. Available only in bugis n great world la… ## 2 ham Ok lar... Joking wif u oni... ## 3 spam Free entry in 2 a wkly comp to win FA Cup final tkts 21st May 2005. Tex… ## 4 ham U dun say so early hor... U c already then say... ## 5 ham Nah I don&#39;t think he goes to usf, he lives around here though ## 6 spam FreeMsg Hey there darling it&#39;s been 3 week&#39;s now and no word back! I&#39;d … The dataset has 2 variables (columns) and 5572 observations (rows). The variable type is of class character. As it indicates whether the message belongs to the category ham or spam we should convert it to a factor variable. rawDF$type &lt;- rawDF$type %&gt;% factor class(rawDF$type) ## [1] &quot;factor&quot; We can also visually inspect the data by creating wordclouds for each sms type. spam &lt;- rawDF %&gt;% filter(type == &quot;spam&quot;) ham &lt;- rawDF %&gt;% filter(type == &quot;ham&quot;) wordcloud(spam$text, max.words = 20, scale = c(4, 0.8), colors= c(&quot;indianred1&quot;,&quot;indianred2&quot;,&quot;indianred3&quot;,&quot;indianred&quot;)) wordcloud(ham$text, max.words = 20, scale = c(4, 0.8), colors= c(&quot;lightsteelblue1&quot;,&quot;lightsteelblue2&quot;,&quot;lightsteelblue3&quot;,&quot;lightsteelblue&quot;)) Question: What differences do you notice? 3.3 Preparation First we need to create a corpus, which refers to a collection of text documents. In our case each sms is considered a text document. We’ll use the Corpus() function from thetm package. rawCorpus &lt;- Corpus(VectorSource(rawDF$text)) inspect(rawCorpus[1:3]) ## &lt;&lt;SimpleCorpus&gt;&gt; ## Metadata: corpus specific: 1, document level (indexed): 0 ## Content: documents: 3 ## ## [1] Go until jurong point, crazy.. Available only in bugis n great world la e buffet... Cine there got amore wat... ## [2] Ok lar... Joking wif u oni... ## [3] Free entry in 2 a wkly comp to win FA Cup final tkts 21st May 2005. Text FA to 87121 to receive entry question(std txt rate)T&amp;C&#39;s apply 08452810075over18&#39;s The corpus contains 5572 documents. Which obviously matches with the number of rows in our dataset. We will use the function tm_map() to do some first cleaning up. First we’ll change everything to lowercase. We’ll also remove numbers as these will contain litle information on a message being spam or not. cleanCorpus &lt;- rawCorpus %&gt;% tm_map(tolower) %&gt;% tm_map(removeNumbers) ## Warning in tm_map.SimpleCorpus(., tolower): transformation drops documents ## Warning in tm_map.SimpleCorpus(., removeNumbers): transformation drops documents For computation efficiency it is important to eliminate all items from a dataset of which you’re rather confident that they’ do’ll add little information to your model. In our case we can expect that words like “and” or “but” will be equally common in both ham and spam messages. We should therefore filter them out before we start modeling. We’ll also remove punctuation. cleanCorpus &lt;- cleanCorpus %&gt;% tm_map(tolower) %&gt;% tm_map(removeWords, stopwords()) %&gt;% tm_map(removePunctuation) ## Warning in tm_map.SimpleCorpus(., tolower): transformation drops documents ## Warning in tm_map.SimpleCorpus(., removeWords, stopwords()): transformation ## drops documents ## Warning in tm_map.SimpleCorpus(., removePunctuation): transformation drops ## documents Now that we have removed certain items, the text lines contain a lot of whitespaces where these items used to be. In our last step we will remove additional whitespace. cleanCorpus &lt;- cleanCorpus %&gt;% tm_map(stripWhitespace) ## Warning in tm_map.SimpleCorpus(., stripWhitespace): transformation drops ## documents Let’s inspect the corpus again. Compare it to the raw version. tibble(Raw = rawCorpus$content[1:3], Clean = cleanCorpus$content[1:3]) ## # A tibble: 3 x 2 ## Raw Clean ## &lt;chr&gt; &lt;chr&gt; ## 1 Go until jurong point, crazy.. Availab… go jurong point crazy available bugis… ## 2 Ok lar... Joking wif u oni... ok lar joking wif u oni ## 3 Free entry in 2 a wkly comp to win FA … free entry wkly comp win fa cup final… Now that we have cleaned up the texts, we are going to transform the messages to a matrix. Each word in the each message will get its own column, each row will be a message and the cells of the matrix will contain a word count. cleanDTM &lt;- cleanCorpus %&gt;% DocumentTermMatrix inspect(cleanDTM) ## &lt;&lt;DocumentTermMatrix (documents: 5572, terms: 7829)&gt;&gt; ## Non-/sparse entries: 42822/43580366 ## Sparsity : 100% ## Maximal term length: 40 ## Weighting : term frequency (tf) ## Sample : ## Terms ## Docs call can free get just know like ltgt now will ## 1085 0 0 0 1 0 0 1 0 0 11 ## 1579 0 0 0 0 0 0 0 18 0 0 ## 1863 0 0 0 0 0 1 1 0 0 0 ## 2158 0 0 0 0 0 0 0 0 0 0 ## 2370 0 0 1 0 0 0 1 0 0 0 ## 2380 0 1 0 0 0 0 0 1 0 0 ## 2434 0 3 1 1 0 0 0 6 0 0 ## 2848 0 0 0 0 0 0 0 0 0 0 ## 3016 0 0 0 0 0 0 0 2 0 0 ## 5105 0 0 1 0 0 0 1 0 0 0 Before we start modeling we need to split all datasets into train and test sets. For this we will use a function from the caret package. The function createDataPartition() can be used to create balanced splits of the data. If the y argument to this function is a factor, the random sampling occurs within each class and should preserve the overall class distribution of the data. In this case we’ll create a 75/25% split. # Create split indices set.seed(1234) trainIndex &lt;- createDataPartition(rawDF$type, p = .75, list = FALSE, times = 1) head(trainIndex) ## Resample1 ## [1,] 1 ## [2,] 2 ## [3,] 4 ## [4,] 5 ## [5,] 6 ## [6,] 7 # Apply split indices to DF trainDF &lt;- rawDF[trainIndex, ] ## Warning: The `i` argument of ``[`()` can&#39;t be a matrix as of tibble 3.0.0. ## Convert to a vector. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. testDF &lt;- rawDF[-trainIndex, ] # Apply split indices to Corpus trainCorpus &lt;- cleanCorpus[trainIndex] testCorpus &lt;- cleanCorpus[-trainIndex] # Apply split indices to DTM trainDTM &lt;- cleanDTM[trainIndex, ] testDTM &lt;- cleanDTM[-trainIndex, ] As you can check (how?) the DTM has almost 7800 features. Remember that each feature in the DTM is a word. Some words will have very few counts and therefore will have limited predictive power. To save on computation time we will eliminate words with low frequencies. freqWords &lt;- trainDTM %&gt;% findFreqTerms(5) trainDTM &lt;- DocumentTermMatrix(trainCorpus, list(dictionary = freqWords)) testDTM &lt;- DocumentTermMatrix(testCorpus, list(dictionary = freqWords)) With this operation we’ve reduced the number of features to around 1200. Another issue is that the Naive Bayes classifier is typically trained on categorical features. We now have numerical matrix with word counts. We will transform the counts into a factor that simply indicates whether the word appears in the document or not. We’ll first build our own function for this and then apply it to each column in the DTM. convert_counts &lt;- function(x) { x &lt;- ifelse(x &gt; 0, 1, 0) %&gt;% factor(levels = c(0,1), labels = c(&quot;No&quot;, &quot;Yes&quot;)) } nColsDTM &lt;- dim(trainDTM)[2] trainDTM &lt;- apply(trainDTM, MARGIN = 2, convert_counts) testDTM &lt;- apply(testDTM, MARGIN = 2, convert_counts) head(trainDTM[,1:10]) ## Terms ## Docs available bugis cine crazy got great point wat world joking ## 1 &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;Yes&quot; &quot;No&quot; ## 2 &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;Yes&quot; ## 3 &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; ## 4 &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; ## 5 &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; ## 6 &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; &quot;No&quot; 3.4 Modeling nbayesModel &lt;- naiveBayes(trainDTM, trainDF$type) predVec &lt;- predict(nbayesModel, testDTM) confusionMatrix(predVec, testDF$type, positive = &quot;spam&quot;, dnn = c(&quot;Prediction&quot;, &quot;True&quot;)) ## Confusion Matrix and Statistics ## ## True ## Prediction ham spam ## ham 1197 29 ## spam 9 157 ## ## Accuracy : 0.9727 ## 95% CI : (0.9627, 0.9806) ## No Information Rate : 0.8664 ## P-Value [Acc &gt; NIR] : &lt; 2.2e-16 ## ## Kappa : 0.8765 ## ## Mcnemar&#39;s Test P-Value : 0.002055 ## ## Sensitivity : 0.8441 ## Specificity : 0.9925 ## Pos Pred Value : 0.9458 ## Neg Pred Value : 0.9763 ## Prevalence : 0.1336 ## Detection Rate : 0.1128 ## Detection Prevalence : 0.1193 ## Balanced Accuracy : 0.9183 ## ## &#39;Positive&#39; Class : spam ## 3.5 Evaluation Figure 3.1: Standard diffusion table. Taken from: https://emj.bmj.com/content/emermed/36/7/431/F1.large.jpg Questions: How would you assess the overall performance of the model? What would you consider as more costly: high false negatives or high false positives levels? Why? References "]]
